#!/usr/bin/env node

'use strict';
const parse = require('xdr-tools').XdrParser,
      path = require('path'),
      fs = require('fs');

if (process.argv.length !== 3) {
  console.log('usage: gen-api <path>');
  process.exit(1);
}

function upperFirst(str) {
  return str.charAt(0).toUpperCase() + str.substring(1);
}

function toCamelCase(str, sep) {
  sep = sep || '_';
  return str.split(sep).map((x, i) => i !== 0 ? upperFirst(x) : x).join('');
}

const LOOKUP_METHODS = [
  'lookupByName', 'lookupById', 'lookupByUuid', 'lookupByKey', 'lookupByPath',
  'lookupByMacString', 'lookupByUsage', 'lookupByVolume'
];

const specPath = process.argv[2];
const input = fs.readFileSync(specPath, 'utf-8');
const result = parse(input.toString());
const structs = result.value.filter(r => r.type === 'struct');
const methods = structs.filter(s => s.name.endsWith('_args') || s.name.endsWith('_ret'));
const api = methods.reduce((def, method) => {
  let suffix = method.name.endsWith('_args') ? '_args' : '_ret';
  let altSuffix = method.name.endsWith('_args') ? '_ret' : '_args';
  let methodBits = method.name.replace('remote_', '').replace(suffix, '').split('_');
  let procName = 'REMOTE_PROC_' + methodBits.map(b => b.toUpperCase()).join('_');
  let section = methodBits.shift();
  if (section === 'storage') { section += '_' + methodBits.shift(); }

  if (!def.hasOwnProperty(section)) def[section] = {};
  let methodName =
    methodBits.map((bit, idx) => idx !== 0 ? upperFirst(bit) : bit).join('');

  let lookupType;
  if (LOOKUP_METHODS.indexOf(methodName) !== -1) {
    methodBits.splice(1, 0, className(section));
    methodName =
      methodBits.map((bit, idx) => idx !== 0 ? upperFirst(bit) : bit).join('');
    lookupType = className(section);
    section = 'connect';
  }

  if (def[section].hasOwnProperty(methodName)) {
    // already processed this method, bail
    return def;
  }

  def[section][methodName] = { proc: procName };
  def[section][methodName][suffix.substring(1)] = method;
  if (!!lookupType) def[section][methodName].lookupType = lookupType;

  let pairName = method.name.replace(suffix, altSuffix);
  const pairMethods = structs.filter(s => s.name === pairName);
  def[section][methodName][altSuffix.substring(1)] =
    (pairMethods.length) ? pairMethods[0] : null;
  return def;
}, {});

function className(moduleName) { return upperFirst(toCamelCase(moduleName)); }
function writeClassDefinition(stream, moduleName, def) {
  stream.write(`class ${className(moduleName)} {\n`);

  if (moduleName === 'connect') {
    stream.write('  constructor() {}\n');
  } else {
    stream.write('  constructor(conn, attr) {\n');
    stream.write('    this.conn = conn;\n');
    stream.write(`    this.ref = new rp.remote_${moduleName}(attr);\n`);
    stream.write('  }\n');
  }
  stream.write('}\n\n');
}

function isRef(module, param) {
  return (module === 'domain' && param === 'dom') ||
         (module === 'interface' && param === 'iface') ||
         (module === 'network' && param === 'net') ||
         (module === 'nwfilter' && param === 'nwfilter') ||
         (module === 'secret' && param === 'secret') ||
         (module === 'storage_pool' && param === 'pool') ||
         (module === 'storage_vol' && param === 'vol');
}

for (let module in api) {
  let stream = fs.createWriteStream(path.resolve('..', `lib/${module}.js`));
  stream.write("'use strict';\nconst rp = {};\nconst proc = rp.remote_procedure;\n\n");

  writeClassDefinition(stream, module, api[module]);

  for (let method in api[module]) {
    let procName = api[module][method].proc;
    let methodArgs = api[module][method].args;
    let methodReturn = api[module][method].ret;
    let lookupType = api[module][method].lookupType;

    let signatureBits = [];
    if (methodArgs) {
      signatureBits = methodArgs.members.map(m => toCamelCase(m.name));
      if (isRef(module, signatureBits[0])) signatureBits.shift();
    }
    signatureBits.push('callback');
    let signature = signatureBits.join(', ');

    // console.dir(api[module][method], { depth: null });
    stream.write('/**\n *\n');
    if (methodArgs) {
      methodArgs.members.map(m => stream.write(` * @param ${toCamelCase(m.name)}\n`));
    }
    stream.write(' * @param [callback]\n');
    stream.write(' */\n');
    stream.write(`${className(module)}.prototype.${method} = function(${signature}) {\n`);

    if (methodArgs) {
      stream.write(`  let data = new rp.${methodArgs.name}({\n`);
      stream.write(methodArgs.members.reduce((out, m) => {
        if (isRef(module, m.name)) {
          out.push(`    ${toCamelCase(m.name)}: this.ref`);
        } else {
          out.push(`    ${toCamelCase(m.name)}: ${toCamelCase(m.name)}`);
        }

        return out;
      }, []).join(',\n'));
      stream.write('\n  });\n\n');
    }

    let maybeData = (!!methodArgs) ? 'data.toXDR()' : 'null';
    stream.write('  let promise = new Promise((resolve, reject) => {\n');
    stream.write('    let cb = (e, r) => (e) ? reject(e) : resolve(r);\n');

    if (module === 'connect') {
      stream.write(`    this.request(proc.${procName}(), ${maybeData}, (err, payload) => {\n`);
    } else {
      stream.write(`    this.conn.request(proc.${procName}(), ${maybeData}, (err, payload) => {\n`);
    }

    stream.write('      if (err) { cb(err, null); return; }\n');

    if (methodReturn) {
      stream.write(`      let result = rp.${methodReturn.name}.fromXDR(payload);\n`);
      stream.write(`      result = result.hasOwnProperty('_attributes') ? result._attributes : result;\n`);
      if (lookupType) {
        stream.write(`      cb(null, new ${lookupType}(this, result));\n`);
      } else {
        stream.write('      cb(null, result);\n');
      }
    } else {
      stream.write('      cb();\n');
    }
    stream.write('    });\n');
    stream.write('  });\n\n');
    stream.write('  return promise.asCallback(callback);\n');
    stream.write('};\n\n');
  }
}
